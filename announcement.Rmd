---
title: "On dashR: an R interface to the dash ecosystem"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  comment = "#>",
  collapse = TRUE
)
```

I'm super excited to announce a new R package, [dashR](https://github.com/plotly/dashR), which is essentially  [dash](https://plot.ly/dash/) for R. With dashR, you can build reactive web applications entirely in R using an API that looks nearly identical to the dash (python) version. That means, if you already know dash, and want/need to leverage R (rather python) functionality, it's straight-forward to translate your existing knowledge/applications from dash to dashR (or vice versa). Dasher also offers some functionality that is unique to R, such as automatic rendering of [htmlwidgets](http://www.htmlwidgets.org/).

## Hello world example

```r

```

## But I already know shiny...why use dashR?

Let's address the elephant in the room. I've [developed shiny apps for over 5 years now](https://github.com/cpsievert/apps/graphs/contributors), so I am very much aware of how awesome shiny is, how huge the community is, and I sincerely hope shiny continues to thrive. That being said, there are numerous dashR features that should make it preferable in some contexts:

1. Agile development

If you work with a team of software engineers and/or data scientists and/or consistently switch between R and python on your projects, then you'll appreciate the ability to quickly switch between an R (dashR) or python (dash) backend with nearly identical code. More specifically, changing from R to python (or vice versa) can be as easy as changing your callback function(s) since the underlying layout and reactivity model ([dash-renderer](https://github.com/plotly/dash-renderer)) is the same. In fact, I was able to port <https://plot.ly/dash> to <https://plot.ly/dashR> in the matter of days since it was a matter of porting a dash app to a dashR app (the most time intensive part was changing python/R specific details).
  
2. Powered by React

React is an extremely popular JavaScript library for building scalable user interfaces (backed and used by Facebook). Each dashR/dash component is actually a wrapper around a React component (e.g. `coreSlider()` is [a wrapper](https://github.com/plotly/dash-core-components/blob/f1add73e/src/components/Slider.react.js#L2) around [rc-slider](https://www.npmjs.com/package/rc-slider)). Moreover, we've provided an [official guide](https://plot.ly/dashR/plugins) for bundling dashR (and dash) compatible React component(s) so that others can use your (or someone else's!) custom component via an R package. That means, you could publish a package (`foo`) with a component (`bar`) to [CRAN](https://cran.r-project.org/) so that others could use it by simply doing:

```r
install.package("foo")
help(foo::bar)
```

And, similarly, in python via pip:

```r
pip install foo
python -c 'import foo; help(foo.bar)'
```

Keep in mind the React community is huge and we've only scratched the surface in terms of converting [awesome React components](https://github.com/brillout/awesome-react-components)!

<!--
TODO:

* Efficient updates thanks to react and react-dom
  * Do a benchmark?
-->

3. AJAX by default


* shiny uses web-sockets by default, which can make deployment difficult, especially in enterprise settings.

4. Apps can be serialized as JSON
  * saving and loading
  
5. True multi-page apps




### Dash HTML components

### Dash core components

Talk about how this sort of thing is difficult in shiny <https://plot.ly/dash/urls> (versus shinyjs hacks, also <http://jaehyeon-kim.github.io/2016/06/Some-Thoughts-On-Shiny-Open-Source-Render-Multiple-Pages.html>)

### AJAX by default

Shiny 

### No global distinction between inputs and outputs

Shiny makes a 'global' distinction between inputs and outputs. There are certain things you can do with input elements that you can't necessarily do with outputs (and vice versa). For example, you can't really (in a generalized sense) obtain a value/property from a shiny output and use it as an input value to another output. This is not the case in dash. It's true that, for a given callback, you need to define what layout elements are input(s) vs output, but the output for one callback might be the input for another callback. 

### More transparent

Market to developers here. For example, shiny adds/removes special class to DOM elements to achieve some of it's magic, making it difficult to customize styling and so forth...


### Web server exposed as first-class citizen

Go into some custom/special things you can do via fiery/routr.

